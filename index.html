<!doctype html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Mobile Poster Generator</title>
  <style>
    @font-face {
      font-family: "AkUltra";
      src: url("fonts/Ak_ultra-Regular.ttf") format("truetype");
      font-display: swap;
    }
    @font-face {
      font-family: "NoiseUltra";
      src: url("fonts/Noise_ultra-Regular.ttf") format("truetype");
      font-display: swap;
    }
    :root {
      --ink: #101010;
      --panel: #ffffff;
      --panel-border: #e0e0e0;
      --accent: #111111;
      --accent-ink: #ffffff;
      --shadow: 0 18px 40px rgba(20, 20, 20, 0.25);
    }
    * {
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
    }
    body {
      margin: 0;
      font-family: "Verdana", "Geneva", sans-serif;
      background: #ffffff;
      color: var(--ink);
      overflow: hidden;
    }
    #app {
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    #stage {
      flex: 1;
      padding: 12px 12px 8px;
      display: flex;
      align-items: stretch;
      justify-content: center;
    }
    #stage canvas {
      width: 100% !important;
      height: 100% !important;
      border-radius: 22px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(0, 0, 0, 0.12);
      background: #f8f8f8;
    }
    #controls {
      padding: 12px 14px 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      background: var(--panel);
      border-top: 1px solid var(--panel-border);
    }
    input[type="text"] {
      width: 100%;
      padding: 12px 14px;
      font-size: 16px;
      border-radius: 16px;
      border: 1px solid var(--panel-border);
      background: rgba(255, 255, 255, 0.9);
      color: var(--ink);
      font-family: inherit;
      letter-spacing: 0.03em;
    }
    input[type="range"] {
      width: 100%;
      appearance: none;
      height: 30px;
      background: transparent;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      height: 4px;
      background: #111111;
      border-radius: 8px;
    }
    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #111111;
      border: 2px solid #ffffff;
      margin-top: -8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }
    input[type="range"]::-moz-range-track {
      height: 4px;
      background: #111111;
      border-radius: 8px;
    }
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #111111;
      border: 2px solid #ffffff;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }
    .control-label {
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #333333;
    }
    button {
      width: 100%;
      border: none;
      border-radius: 18px;
      padding: 14px 16px;
      font-size: 16px;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      background: var(--accent);
      color: var(--accent-ink);
      box-shadow: 0 12px 24px rgba(17, 17, 17, 0.28);
    }
    button.secondary {
      background: #ffffff;
      color: var(--ink);
      border: 1px solid var(--panel-border);
      font-size: 13px;
      padding: 10px 12px;
      letter-spacing: 0.12em;
      box-shadow: none;
    }
    button:active {
      transform: translateY(1px);
    }
    @media (min-width: 700px) {
      #app {
        max-width: 520px;
        margin: 0 auto;
      }
      #stage {
        padding: 18px;
      }
      #controls {
        border-radius: 22px 22px 0 0;
      }
    }
  </style>
  <script src="libs/p5.min.js"></script>
</head>
<body>
  <main id="app">
    <section id="stage" aria-label="Poster Preview"></section>
    <section id="controls">
      <input id="textInput" type="text" placeholder="Poster Text" maxlength="80" aria-label="Poster Text">
      <label class="control-label" for="sizeInput">Font Groesse</label>
      <input id="sizeInput" type="range" min="32" max="160" value="96" step="2" aria-label="Schriftgroesse">
      <label class="control-label" for="randomInput">Randomness</label>
      <input id="randomInput" type="range" min="0" max="100" value="80" step="1" aria-label="Randomness">
      <button id="generateBtn" type="button">Erstelle Poster</button>
      <button id="downloadBtn" class="secondary" type="button">Download</button>
    </section>
  </main>

  <script>
    const BG_IMAGE_IDS = [
      10, 11, 12, 13, 14, 15, 16, 18, 19, 20,
      21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
      31, 32, 33, 34, 35, 36, 37, 38, 39, 40
    ];

    const FONT_FILES = [
      "fonts/Ak_ultra-Regular.ttf",
      "fonts/block_ultra.otf",
      "fonts/CH1_ultra.otf",
      "fonts/DRN_ultra.otf",
      "fonts/echo_ultra.otf",
      "fonts/Fck_ultra-Regular.ttf",
      "fonts/franzi_ultra.otf",
      "fonts/INK_ultra.otf",
      "fonts/KID_ultra.otf",
      "fonts/LLO_ultra.otf",
      "fonts/NOISE2_ultra.otf",
      "fonts/Noise_ultra-Regular.ttf",
      "fonts/Rb_ultra-Regular.ttf",
      "fonts/sonar_ultra.otf",
      "fonts/slice_ultra.otf",
      "fonts/TRB_ultra.otf",
      "fonts/TSU_ultra.otf",
      "fonts/Vv_ultra-Regular.ttf"
    ];
    const MOBILE_FONT_FILES = [
      ...FONT_FILES
    ];

    let BLEND_MODES = [];
    let FILTERS = [];

    let loadedFonts = [];
    let posterState = null;
    let isMobile = false;
    let maxCanvasSize = 1600;
    let bgImageSize = { w: 1600, h: 2200 };
    let allowBackgroundImages = true;
    let fxScale = 1;
    let textFxScale = 1;
    let textLayer = null;

    function randByFactor(min, max, factor) {
      const center = (min + max) / 2;
      const spread = (max - min) / 2;
      return center + random(-spread, spread) * factor;
    }

    function randIntByFactor(min, max, factor) {
      return Math.max(1, Math.round(randByFactor(min, max, factor)));
    }

    function getLuma(p5color) {
      return red(p5color) * 0.299 + green(p5color) * 0.587 + blue(p5color) * 0.114;
    }

    function randomPunchColor() {
      const base = random([
        [255, 36, 0],
        [255, 0, 84],
        [255, 0, 255],
        [124, 0, 255],
        [0, 80, 255],
        [0, 198, 255],
        [0, 255, 180],
        [0, 255, 60],
        [120, 255, 0],
        [255, 220, 0]
      ]);
      const jitter = 18;
      return color(
        constrain(base[0] + random(-jitter, jitter), 0, 255),
        constrain(base[1] + random(-jitter, jitter), 0, 255),
        constrain(base[2] + random(-jitter, jitter), 0, 255)
      );
    }

    function randomPunchBg() {
      const base = random([
        [8, 8, 12],
        [12, 12, 18],
        [6, 10, 24],
        [10, 6, 20],
        [16, 6, 8],
        [6, 16, 10]
      ]);
      const jitter = 8;
      return color(
        constrain(base[0] + random(-jitter, jitter), 0, 255),
        constrain(base[1] + random(-jitter, jitter), 0, 255),
        constrain(base[2] + random(-jitter, jitter), 0, 255)
      );
    }

    function buildTextSafeZone(fontSize) {
      return {
        x: width / 2,
        y: height / 2,
        w: width * 0.72,
        h: fontSize * 2.8
      };
    }

    function overlapsBox(x, y, w, h, box) {
      if (!box) return false;
      return Math.abs(x - box.x) < (w / 2 + box.w / 2) &&
        Math.abs(y - box.y) < (h / 2 + box.h / 2);
    }

    function placeOutsideSafeZone(getX, getY, w, h, safeZone) {
      if (!safeZone) {
        return { x: getX(), y: getY() };
      }
      for (let i = 0; i < 10; i++) {
        const x = getX();
        const y = getY();
        if (!overlapsBox(x, y, w, h, safeZone)) {
          return { x, y };
        }
      }
      return { x: getX(), y: getY() };
    }

    function getTextLayer() {
      if (!textLayer || textLayer.width !== width || textLayer.height !== height) {
        textLayer = createGraphics(width, height);
        textLayer.pixelDensity(1);
        textLayer.angleMode(DEGREES);
      }
      return textLayer;
    }

    function preload() {
      updatePerfProfile();
      const fontList = isMobile ? MOBILE_FONT_FILES : FONT_FILES;
      loadedFonts = fontList.map(path => loadFont(path));
    }

    function setup() {
      const stage = document.getElementById("stage");
      updatePerfProfile();
      const { w, h } = getCanvasSize(stage.clientWidth, stage.clientHeight);
      const canvas = createCanvas(w, h);
      canvas.parent(stage);
      angleMode(DEGREES);
      textAlign(CENTER, CENTER);
      imageMode(CENTER);
      rectMode(CENTER);
      pixelDensity(1);
      noLoop();

      BLEND_MODES = [
        BLEND,
        ADD,
        MULTIPLY,
        SCREEN,
        DIFFERENCE,
        EXCLUSION,
        OVERLAY,
        HARD_LIGHT,
        SOFT_LIGHT,
        DODGE,
        BURN
      ];

      FILTERS = isMobile
        ? [null, { mode: GRAY }, { mode: THRESHOLD, value: 1 }]
        : [
          { mode: THRESHOLD, value: 1 },
          { mode: INVERT },
          { mode: GRAY },
          { mode: POSTERIZE, value: 2 },
          { mode: BLUR, value: 12 },
          { mode: ERODE },
          { mode: DILATE }
        ];

      const textInput = document.getElementById("textInput");
      const sizeInput = document.getElementById("sizeInput");
      const randomInput = document.getElementById("randomInput");
      const generateBtn = document.getElementById("generateBtn");
      const downloadBtn = document.getElementById("downloadBtn");

      generateBtn.addEventListener("click", generatePoster);
      downloadBtn.addEventListener("click", downloadPoster);
      textInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") generatePoster();
      });

      generatePoster();
    }

    function windowResized() {
      const stage = document.getElementById("stage");
      updatePerfProfile();
      const { w, h } = getCanvasSize(stage.clientWidth, stage.clientHeight);
      resizeCanvas(w, h);
      drawPoster();
    }

    function generatePoster() {
      const textInput = document.getElementById("textInput");
      const sizeInput = document.getElementById("sizeInput");
      const randomInput = document.getElementById("randomInput");
      const content = (textInput.value || "").trim() || "POSTER";
      const fontSize = parseInt(sizeInput.value, 10) || 96;
      const randomness = Math.min(1, Math.max(0, parseInt(randomInput.value, 10) / 100));
      const calmMode = random() < map(randomness, 0, 1, 0.65, 0.2);
      const safeZone = buildTextSafeZone(fontSize);

      const bgColor = randomPunchBg();
      const textColor = randomPunchColor();
      const accentColor = randomPunchColor();

      posterState = {
        text: content,
        fontSize,
        bgColor,
        textColor,
        accentColor,
        randomness,
        calmMode,
        safeZone,
        font: random(loadedFonts),
        blend: random(BLEND_MODES),
        filter: random(FILTERS),
        textRotation: randByFactor(calmMode ? -14 : -40, calmMode ? 14 : 40, randomness) +
          randByFactor(calmMode ? -60 : -220, calmMode ? 60 : 220, randomness),
        stamps: buildStamps(randomness, calmMode),
        bgTiles: buildBackgroundTiles(randomness, bgColor, calmMode, safeZone),
        seed: floor(random(1, 1000000)),
        ghostLayer: {
          blend: random(BLEND_MODES),
          rotation: randByFactor(calmMode ? -16 : -40, calmMode ? 16 : 40, randomness) +
            randByFactor(calmMode ? -80 : -200, calmMode ? 80 : 200, randomness),
          scale: randByFactor(calmMode ? 1.02 : 1.1, calmMode ? 1.35 : 1.8, randomness),
          offsetX: randByFactor(-width * 0.04, width * 0.04, randomness) + randByFactor(-width * 0.12, width * 0.12, randomness),
          offsetY: randByFactor(-height * 0.04, height * 0.04, randomness) + randByFactor(-height * 0.12, height * 0.12, randomness),
          alpha: randByFactor(calmMode ? 40 : 110, calmMode ? 110 : 180, randomness)
        }
      };

      loadBackgroundTiles(posterState.bgTiles);

      drawPoster();
    }

    function downloadPoster() {
      drawPoster();
      saveCanvas("poster", "png");
    }

    function buildStamps(randomness, calmMode) {
      const stamps = [];
      const minCount = calmMode ? (isMobile ? 1 : 4) : (isMobile ? 2 : 10);
      const maxCount = calmMode ? (isMobile ? 4 : 10) : (isMobile ? 6 : 22);
      const count = randIntByFactor(minCount, maxCount, randomness);
      for (let i = 0; i < count; i++) {
        const scatter = calmMode ? false : (isMobile ? false : random() < (0.25 + randomness * 0.6));
        const edgeX = randByFactor(width * 0.22, width * 0.5, randomness);
        const edgeY = randByFactor(height * 0.22, height * 0.5, randomness);
        const offsetX = calmMode
          ? (random() < 0.5 ? -edgeX : edgeX)
          : randByFactor(-width * 0.15, width * 0.15, randomness) + randByFactor(-width * 0.45, width * 0.45, randomness);
        const offsetY = calmMode
          ? (random() < 0.5 ? -edgeY : edgeY)
          : randByFactor(-height * 0.15, height * 0.15, randomness) + randByFactor(-height * 0.45, height * 0.45, randomness);
        stamps.push({
          x: offsetX,
          y: offsetY,
          rotation: randByFactor(calmMode ? -25 : -60, calmMode ? 25 : 60, randomness) +
            randByFactor(calmMode ? -120 : -260, calmMode ? 120 : 260, randomness),
          scale: randByFactor(calmMode ? 0.7 : 0.6, calmMode ? 1.25 : 1.6, randomness) +
            randByFactor(calmMode ? 0.2 : 0.3, calmMode ? 1.3 : 2.2, randomness) * 0.4,
          alpha: randByFactor(calmMode ? 70 : 150, calmMode ? 190 : 255, randomness),
          color: color(random(0, 255), random(0, 255), random(0, 255)),
          strokeColor: color(random(0, 255), random(0, 255), random(0, 255)),
          strokeWeight: randByFactor(1, calmMode ? 4 : 6, randomness),
          strokeOn: random() < (calmMode ? 0.25 : (0.35 + randomness * 0.45)),
          scatter,
          jitter: randByFactor(isMobile ? 2 : 4, isMobile ? (calmMode ? 4 : 6) : (calmMode ? 10 : 18), randomness),
          blend: calmMode ? random([BLEND, SOFT_LIGHT, MULTIPLY]) : random(BLEND_MODES),
          font: random(loadedFonts)
        });
      }
      return stamps;
    }

    function buildBackgroundTiles(randomness, bgColor, calmMode, safeZone) {
      const tiles = [];
      let minCount;
      let maxCount;
      if (isMobile) {
        minCount = calmMode ? 1 : 2;
        maxCount = calmMode ? 4 : 8;
      } else {
        minCount = calmMode ? 4 : 10;
        maxCount = calmMode ? 10 : 24;
      }
      const count = randIntByFactor(minCount, maxCount, randomness);
      const base = min(width, height);
      for (let i = 0; i < count; i++) {
        const size = randByFactor(
          base * (calmMode ? 0.24 : 0.28) * (isMobile ? 1.1 : 1),
          base * (calmMode ? 0.55 : 0.7) * (isMobile ? 0.9 : 1),
          randomness
        );
        const aspect = randByFactor(isMobile ? 0.85 : 0.7, isMobile ? 1.35 : 1.6, randomness);
        const w = size * aspect;
        const h = size / aspect;
        const pos = placeOutsideSafeZone(
          () => randByFactor(width * 0.15, width * 0.85, randomness),
          () => randByFactor(height * 0.15, height * 0.85, randomness),
          w,
          h,
          calmMode ? safeZone : null
        );
        const tintColor = calmMode
          ? lerpColor(bgColor, color(255), 0.6)
          : color(random(0, 255), random(0, 255), random(0, 255));
        tiles.push({
          url: getBgImageUrl(),
          x: pos.x,
          y: pos.y,
          w,
          h,
          rotation: randByFactor(calmMode ? -18 : -40, calmMode ? 18 : 40, randomness) +
            randByFactor(calmMode ? -80 : -120, calmMode ? 80 : 120, randomness),
          alpha: randByFactor(calmMode ? 80 : 140, calmMode ? 190 : 240, randomness),
          blend: calmMode ? random([BLEND, SOFT_LIGHT, MULTIPLY]) : random(BLEND_MODES),
          tint: tintColor,
          frameOn: random() < (calmMode ? 0.2 : (0.2 + randomness * 0.6)),
          img: null
        });
      }
      return tiles;
    }

    function loadBackgroundTiles(tiles) {
      if (!allowBackgroundImages || !tiles.length) return;
      tiles.forEach((tile) => {
        loadImage(
          tile.url,
          (img) => {
            tile.img = img;
            drawPoster();
          },
          () => {
            tile.img = null;
            drawPoster();
          }
        );
      });
    }

    function drawPoster() {
      if (!posterState) return;
      randomSeed(posterState.seed);
      noiseSeed(posterState.seed);
      background(posterState.bgColor);
      drawBackgroundImage();
      applyCollageFX();
      applyFilter();
      drawTextLayers();
    }

    function applyCollageFX() {
      const intensity = (posterState.calmMode ? 0.45 : 1) * fxScale;
      applySliceGlitch(intensity);
      applyStripShuffle(intensity);
      applyNoiseWarp(intensity);
      applyTileMosaic(intensity);
      applyCutoutWindows(intensity);
      applyPosterizeWindows(intensity);
      applyPixelSortStrips(intensity);
      drawEdgeFrames(intensity);
    }

    function applySliceGlitch(intensity) {
      const sliceCount = Math.round(map(posterState.randomness, 0, 1, 2, 10) * intensity);
      for (let i = 0; i < sliceCount; i++) {
        const y = random(0, height);
        const h = random(6, 40) * intensity;
        const xShift = random(-width * 0.08, width * 0.08) * posterState.randomness;
        copy(0, y, width, h, xShift, y, width, h);
      }
    }

    function applyStripShuffle(intensity) {
      const vCount = Math.round(map(posterState.randomness, 0, 1, 2, 8) * intensity);
      for (let i = 0; i < vCount; i++) {
        const x = random(0, width);
        const w = random(6, 28) * intensity;
        const yShift = random(-height * 0.08, height * 0.08) * posterState.randomness;
        copy(x, 0, w, height, x, yShift, w, height);
      }
    }

    function applyNoiseWarp(intensity) {
      const band = Math.max(isMobile ? 18 : 10, Math.round(map(posterState.randomness, 0, 1, 26, 10)));
      for (let y = 0; y < height; y += band) {
        const n = noise(y * 0.02, posterState.seed * 0.0002);
        const shift = map(n, 0, 1, -width * 0.06, width * 0.06) * posterState.randomness * intensity * (isMobile ? 0.7 : 1);
        copy(0, y, width, band, shift, y, width, band);
      }
    }

    function applyTileMosaic(intensity) {
      const cellCount = Math.round(map(posterState.randomness, 0, 1, 6, 22) * intensity);
      for (let i = 0; i < cellCount; i++) {
        const w = random(width * 0.08, width * 0.22);
        const h = random(height * 0.08, height * 0.22);
        const sx = random(0, width - w);
        const sy = random(0, height - h);
        const dx = sx + random(-width * 0.06, width * 0.06) * posterState.randomness * (isMobile ? 0.6 : 1);
        const dy = sy + random(-height * 0.06, height * 0.06) * posterState.randomness * (isMobile ? 0.6 : 1);
        const scale = 1 + random(-0.12, 0.16) * posterState.randomness * (isMobile ? 0.6 : 1);
        copy(sx, sy, w, h, dx, dy, w * scale, h * scale);
      }
    }

    function applyCutoutWindows(intensity) {
      const tiles = posterState.bgTiles || [];
      const sources = tiles.filter(tile => tile.img);
      const count = Math.round(map(posterState.randomness, 0, 1, 2, 7) * intensity);
      for (let i = 0; i < count; i++) {
        const w = random(width * 0.18, width * 0.42);
        const h = random(height * 0.12, height * 0.32);
        const x = random(w * 0.5, width - w * 0.5);
        const y = random(h * 0.5, height - h * 0.5);
        const shape = random(["rect", "circle", "tri"]);
        const ctx = drawingContext;
        ctx.save();
        ctx.beginPath();
        if (shape === "circle") {
          ctx.ellipse(x, y, w * 0.5, h * 0.5, 0, 0, Math.PI * 2);
        } else if (shape === "tri") {
          ctx.moveTo(x - w * 0.5, y + h * 0.4);
          ctx.lineTo(x, y - h * 0.5);
          ctx.lineTo(x + w * 0.5, y + h * 0.35);
          ctx.closePath();
        } else {
          ctx.rect(x - w * 0.5, y - h * 0.5, w, h);
        }
        ctx.clip();
        push();
        translate(x, y);
        rotate(random(-20, 20) * posterState.randomness * (isMobile ? 0.7 : 1));
        const tile = sources.length ? random(sources) : null;
        if (tile) {
          image(tile.img, 0, 0, w * 1.1, h * 1.1);
        } else {
          noStroke();
          fill(255, 255, 255, 120);
          rect(0, 0, w, h);
        }
        pop();
        ctx.restore();
      }
    }

    function applyPosterizeWindows(intensity) {
      let count = Math.round(map(posterState.randomness, 0, 1, 1, 4) * intensity);
      if (isMobile) count = Math.min(1, count);
      for (let i = 0; i < count; i++) {
        const w = random(width * 0.12, width * 0.3);
        const h = random(height * 0.12, height * 0.3);
        const x = random(0, width - w);
        const y = random(0, height - h);
        const grab = get(x, y, w, h);
        grab.filter(POSTERIZE, random([2, 3, 4]));
        if (random() < 0.4) {
          grab.filter(THRESHOLD, random(0.45, 0.7));
        }
        image(grab, x, y, w, h);
      }
    }

    function applyPixelSortStrips(intensity) {
      if (isMobile) return;
      const count = Math.round(map(posterState.randomness, 0, 1, 1, 3) * intensity);
      for (let i = 0; i < count; i++) {
        const stripW = Math.round(random(6, 14));
        const stripH = Math.round(random(height * 0.18, height * 0.45));
        const x = Math.round(random(0, width - stripW));
        const y = Math.round(random(0, height - stripH));
        const img = get(x, y, stripW, stripH);
        img.loadPixels();
        for (let col = 0; col < stripW; col++) {
          const column = [];
          for (let row = 0; row < stripH; row++) {
            const idx = 4 * (row * stripW + col);
            const r = img.pixels[idx];
            const g = img.pixels[idx + 1];
            const b = img.pixels[idx + 2];
            const a = img.pixels[idx + 3];
            const luma = r * 0.299 + g * 0.587 + b * 0.114;
            column.push({ r, g, b, a, luma });
          }
          column.sort((a, b) => a.luma - b.luma);
          for (let row = 0; row < stripH; row++) {
            const idx = 4 * (row * stripW + col);
            const px = column[row];
            img.pixels[idx] = px.r;
            img.pixels[idx + 1] = px.g;
            img.pixels[idx + 2] = px.b;
            img.pixels[idx + 3] = px.a;
          }
        }
        img.updatePixels();
        image(img, x, y, stripW, stripH);
      }
    }

    function drawEdgeFrames(intensity) {
      const frameCount = Math.round(map(posterState.randomness, 0, 1, 2, 6) * intensity);
      push();
      noFill();
      stroke(0, 40);
      strokeWeight(2);
      for (let i = 0; i < frameCount; i++) {
        const inset = i * random(6, 16);
        rect(width / 2, height / 2, width - inset * 2, height - inset * 2);
      }
      pop();
      const tapeCount = Math.round(map(posterState.randomness, 0, 1, 1, 4) * intensity);
      for (let i = 0; i < tapeCount; i++) {
        const w = random(width * 0.1, width * 0.22);
        const h = random(height * 0.02, height * 0.05);
        const x = random(w * 0.6, width - w * 0.6);
        const y = random(h * 0.6, height - h * 0.6);
        push();
        translate(x, y);
        rotate(random(-18, 18));
        noStroke();
        fill(255, 255, 255, 110);
        rect(0, 0, w, h, h / 2);
        pop();
      }
    }

    function drawBackgroundImage() {
      const tiles = posterState.bgTiles || [];
      if (!allowBackgroundImages) {
        drawFallbackTexture();
        return;
      }
      if (!tiles.length) {
        drawFallbackTexture();
        return;
      }

      for (const tile of tiles) {
        push();
        translate(tile.x, tile.y);
        rotate(tile.rotation);
        blendMode(tile.blend);
        const chopChance = posterState.calmMode ? 0.2 : (0.35 + posterState.randomness * 0.4);
        const chopIt = tile.img && random() < chopChance;
        if (chopIt) {
          drawChoppedTile(tile);
        } else if (tile.img) {
          tint(red(tile.tint), green(tile.tint), blue(tile.tint), tile.alpha);
          image(tile.img, 0, 0, tile.w, tile.h);
        } else {
          noStroke();
          fill(255, 255, 255, tile.alpha * 0.6);
          rect(0, 0, tile.w, tile.h);
        }
        if (tile.frameOn) {
          noFill();
          stroke(0, 40);
          strokeWeight(2);
          rect(0, 0, tile.w * 1.04, tile.h * 1.04);
        }
        pop();
      }
      blendMode(BLEND);
      noTint();
    }

    function drawChoppedTile(tile) {
      const pieces = randIntByFactor(2, 5, posterState.randomness);
      const imgW = tile.img ? tile.img.width : tile.w;
      const imgH = tile.img ? tile.img.height : tile.h;
      for (let i = 0; i < pieces; i++) {
        const rx = random(0, 0.7);
        const ry = random(0, 0.7);
        const rw = random(0.2, 0.6);
        const rh = random(0.2, 0.6);
        const dx = (rx + rw / 2 - 0.5) * tile.w + random(-tile.w * 0.06, tile.w * 0.06) * posterState.randomness;
        const dy = (ry + rh / 2 - 0.5) * tile.h + random(-tile.h * 0.06, tile.h * 0.06) * posterState.randomness;
        if (tile.img) {
          tint(red(tile.tint), green(tile.tint), blue(tile.tint), tile.alpha);
          image(tile.img, dx, dy, rw * tile.w, rh * tile.h, rx * imgW, ry * imgH, rw * imgW, rh * imgH);
        } else {
          noStroke();
          fill(255, 255, 255, tile.alpha * 0.6);
          rect(dx, dy, rw * tile.w, rh * tile.h);
        }
      }
    }

    function drawFallbackTexture() {
      noStroke();
      const bands = 6;
      for (let i = 0; i < bands; i++) {
        const offset = map(i, 0, bands - 1, -width * 0.6, width * 0.6);
        fill(255, 255, 255, 40);
        push();
        rotate(i * 12);
        rect(offset, 0, width * 0.4, height * 1.4);
        pop();
      }
    }

    function drawTextLayers() {
      if (!posterState.font) return;
      const baseSize = Math.min(posterState.fontSize, width * 1.05);
      textLeading(baseSize * 0.9);

      const ghost = posterState.ghostLayer;
      blendMode(ghost.blend);
      push();
      translate(width / 2 + ghost.offsetX, height / 2 + ghost.offsetY);
      rotate(ghost.rotation);
      textFont(posterState.font);
      textSize(baseSize * ghost.scale);
      noStroke();
      const ghostAlpha = posterState.calmMode ? ghost.alpha * 0.35 : ghost.alpha;
      fill(red(posterState.accentColor), green(posterState.accentColor), blue(posterState.accentColor), ghostAlpha);
      drawWrappedText(posterState.text, width * 0.92);
      pop();

      for (const stamp of posterState.stamps) {
        push();
        translate(width / 2 + stamp.x, height / 2 + stamp.y);
        rotate(posterState.textRotation + stamp.rotation);
        textFont(stamp.font || posterState.font);
        textSize(baseSize * stamp.scale);
        textLeading(baseSize * stamp.scale * 0.92);
        blendMode(stamp.blend);
        if (stamp.strokeOn) {
          stroke(red(stamp.strokeColor), green(stamp.strokeColor), blue(stamp.strokeColor), stamp.alpha);
          strokeWeight(stamp.strokeWeight);
        } else {
          noStroke();
        }
        fill(red(stamp.color), green(stamp.color), blue(stamp.color), stamp.alpha);
        if (stamp.scatter) {
          drawExplodedText(posterState.text, width * 0.8, stamp.jitter);
        } else {
          drawWrappedText(posterState.text, width * 0.78);
        }
        pop();
      }

      drawMainText(baseSize);
      blendMode(BLEND);
    }

    function drawMainText(baseSize) {
      const content = posterState.text;
      if (!content) return;

      const g = getTextLayer();
      g.clear();
      g.textFont(posterState.font);
      g.textAlign(LEFT, CENTER);
      g.textSize(baseSize * 1.05);
      g.textLeading(baseSize * 0.95);

      const maxWidth = width * 0.86;
      const lines = getWrappedLines(content, maxWidth, (text) => g.textWidth(text));
      const lineHeight = g.textLeading();
      let maxLineWidth = 0;
      for (const line of lines) {
        maxLineWidth = Math.max(maxLineWidth, g.textWidth(line));
      }
      const startX = -maxLineWidth / 2;
      const startY = -(lines.length - 1) * lineHeight * 0.5;
      const stretch = map(posterState.randomness, 0, 1, 0.02, 0.18) * (posterState.calmMode ? 0.5 : 1);
      const breakShift = map(posterState.randomness, 0, 1, 1, 12) * (posterState.calmMode ? 0.5 : 1);
      const outline = getLuma(posterState.textColor) < 140
        ? color(255, 255, 255, 140)
        : color(0, 0, 0, 140);

      g.push();
      g.translate(width / 2, height / 2);
      g.stroke(red(outline), green(outline), blue(outline), alpha(outline));
      g.strokeWeight(2);
      g.fill(red(posterState.textColor), green(posterState.textColor), blue(posterState.textColor), 240);

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const lineWidth = g.textWidth(line);
        const lineX = startX;
        const y = startY + i * lineHeight;
        const breakAt = lineX + lineWidth * random(0.35, 0.65);
        const scaleX = 1 + random(-stretch, stretch);
        const leftShift = random(-breakShift, breakShift);
        const rightShift = random(-breakShift, breakShift);

        const ctx = g.drawingContext;
        ctx.save();
        ctx.beginPath();
        ctx.rect(lineX - 6, y - lineHeight * 0.6, breakAt - lineX + 6, lineHeight * 1.2);
        ctx.clip();
        g.push();
        g.scale(scaleX, 1);
        g.text(line, (lineX + leftShift) / scaleX, y);
        g.pop();
        ctx.restore();

        ctx.save();
        ctx.beginPath();
        ctx.rect(breakAt, y - lineHeight * 0.6, lineX + lineWidth - breakAt + 8, lineHeight * 1.2);
        ctx.clip();
        g.push();
        g.scale(scaleX, 1);
        g.text(line, (lineX + rightShift) / scaleX, y + random(-2, 2) * posterState.randomness);
        g.pop();
        ctx.restore();
      }
      g.pop();

      applyTextFX(g);
      image(g, 0, 0);
    }

    function applyTextFX(g) {
      const intensity = (posterState.calmMode ? 0.35 : 0.8) * textFxScale;
      applyTextSliceGlitch(g, intensity);
      applyTextStripShuffle(g, intensity);
      applyTextNoiseWarp(g, intensity);
      applyTextPosterize(g, intensity);
    }

    function applyTextSliceGlitch(g, intensity) {
      const sliceCount = Math.round(map(posterState.randomness, 0, 1, 1, 5) * intensity);
      for (let i = 0; i < sliceCount; i++) {
        const y = random(height * 0.2, height * 0.8);
        const h = random(4, 18) * intensity;
        const xShift = random(-width * 0.05, width * 0.05) * posterState.randomness;
        g.copy(0, y, width, h, xShift, y, width, h);
      }
    }

    function applyTextStripShuffle(g, intensity) {
      const vCount = Math.round(map(posterState.randomness, 0, 1, 1, 4) * intensity);
      for (let i = 0; i < vCount; i++) {
        const x = random(width * 0.2, width * 0.8);
        const w = random(4, 16) * intensity;
        const yShift = random(-height * 0.05, height * 0.05) * posterState.randomness;
        g.copy(x, 0, w, height, x, yShift, w, height);
      }
    }

    function applyTextNoiseWarp(g, intensity) {
      const band = Math.max(isMobile ? 16 : 8, Math.round(map(posterState.randomness, 0, 1, 20, 10)));
      for (let y = 0; y < height; y += band) {
        const n = noise(y * 0.02, posterState.seed * 0.0003);
        const shift = map(n, 0, 1, -width * 0.04, width * 0.04) * posterState.randomness * intensity * (isMobile ? 0.7 : 1);
        g.copy(0, y, width, band, shift, y, width, band);
      }
    }

    function applyTextPosterize(g, intensity) {
      let count = Math.round(map(posterState.randomness, 0, 1, 1, 3) * intensity);
      if (isMobile) count = Math.min(1, count);
      for (let i = 0; i < count; i++) {
        const w = random(width * 0.12, width * 0.26);
        const h = random(height * 0.08, height * 0.2);
        const x = random(width * 0.2, width * 0.8 - w);
        const y = random(height * 0.2, height * 0.8 - h);
        const grab = g.get(x, y, w, h);
        grab.filter(POSTERIZE, random([2, 3, 4]));
        if (random() < 0.35) {
          grab.filter(THRESHOLD, random(0.45, 0.7));
        }
        g.image(grab, x, y, w, h);
      }
    }

    function getWrappedLines(content, maxWidth, measureFn) {
      const words = content.split(/\s+/).filter(Boolean);
      const lines = [];
      const measure = measureFn || textWidth;

      if (words.length === 1 && measure(content) > maxWidth) {
        let line = "";
        for (const ch of content.split("")) {
          const test = line + ch;
          if (measure(test) > maxWidth && line) {
            lines.push(line);
            line = ch;
          } else {
            line = test;
          }
        }
        if (line) lines.push(line);
        return lines;
      }

      let line = "";
      for (const word of words) {
        const test = line ? `${line} ${word}` : word;
        if (measure(test) > maxWidth && line) {
          lines.push(line);
          line = word;
        } else {
          line = test;
        }
      }
      if (line) lines.push(line);
      return lines;
    }

    function drawExplodedText(content, maxWidth, jitter) {
      const lines = getWrappedLines(content, maxWidth);
      if (!lines.length) {
        text(content, 0, 0);
        return;
      }

      textAlign(LEFT, CENTER);
      const totalHeight = lines.length * textLeading();
      const startY = -totalHeight / 2 + textLeading() / 2;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const lineWidth = textWidth(line);
        let cursor = -lineWidth / 2;
        const y = startY + i * textLeading();
        for (const ch of line.split("")) {
          const chWidth = textWidth(ch);
          text(ch, cursor + chWidth / 2 + random(-jitter, jitter), y + random(-jitter, jitter));
          cursor += chWidth;
        }
      }
      textAlign(CENTER, CENTER);
    }

    function drawWrappedText(content, maxWidth) {
      const lines = getWrappedLines(content, maxWidth);

      if (!lines.length) {
        text(content, 0, 0);
        return;
      }

      const totalHeight = lines.length * textLeading();
      const startY = -totalHeight / 2 + textLeading() / 2;
      for (let i = 0; i < lines.length; i++) {
        text(lines[i], 0, startY + i * textLeading());
      }
    }

    function applyFilter() {
      const effect = posterState.filter;
      if (!effect) return;
      if (typeof effect.value === "number") {
        filter(effect.mode, effect.value);
      } else {
        filter(effect.mode);
      }
    }

    function updatePerfProfile() {
      isMobile = window.matchMedia("(max-width: 700px)").matches || /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent);
      maxCanvasSize = isMobile ? 560 : 1600;
      bgImageSize = isMobile ? { w: 420, h: 560 } : { w: 1600, h: 2200 };
      allowBackgroundImages = true;
      fxScale = isMobile ? 0.6 : 1;
      textFxScale = isMobile ? 0.55 : 1;
    }

    function getCanvasSize(width, height) {
      const scale = Math.min(1, maxCanvasSize / Math.max(width, height));
      return {
        w: Math.round(width * scale),
        h: Math.round(height * scale)
      };
    }

    function getBgImageUrl() {
      const id = random(BG_IMAGE_IDS);
      return `https://picsum.photos/id/${id}/${bgImageSize.w}/${bgImageSize.h}`;
    }
  </script>
</body>
</html>
